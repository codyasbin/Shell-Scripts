<#
Apply-RenamesFromCsv.ps1

Reads a CSV generated by Export-RenameMap.ps1 and renames files accordingly.

CSV must have at least:
  OriginalName (or FullPath) and BillNumber columns.

Usage:
  # Preview (default)
  .\Apply-RenamesFromCsv.ps1 -CsvPath "$env:USERPROFILE\Desktop\rename_map.csv"

  # Apply renames
  .\Apply-RenamesFromCsv.ps1 -CsvPath "$env:USERPROFILE\Desktop\rename_map.csv" -Apply

Notes:
 - Script does not change timestamps.
 - Uses temp GUID names to avoid name collisions.
 - Sanitizes BillNumber to remove illegal filename characters.
#>

param(
    [string]$CsvPath = ([Environment]::GetFolderPath('Desktop') + '\rename_map.csv'),
    [switch]$Apply,
    [string]$NameTemplate = '{0} - Bill {1}{2}'  # {0}=Index padded, {1}=BillNumber, {2}=Extension
)

if (-not (Test-Path -LiteralPath $CsvPath)) {
    Write-Error "CSV not found: $CsvPath"
    exit 1
}

# Read CSV
$rows = Import-Csv -Path $CsvPath

if ($rows.Count -eq 0) {
    Write-Error "CSV is empty or malformed."
    exit 1
}

# Validate rows have BillNumber (preview will show missing)
Write-Host "Preview of renames from CSV: `n"
$map = [System.Collections.Generic.List[psobject]]::new()
foreach ($r in $rows) {
    # Determine original full path - prefer FullPath column if present else reconstruct
    $origFull = $null
    if ($r.PSObject.Properties.Match('FullPath').Count -gt 0 -and $r.FullPath) {
        $origFull = $r.FullPath
    } elseif ($r.PSObject.Properties.Match('OriginalName').Count -gt 0 -and $r.OriginalName) {
        # try to find file in same folder as CSV's folder? we will attempt to search
        $csvFolder = Split-Path -Parent $CsvPath
        # If OriginalName includes path separators, assume it's full path
        if ($r.OriginalName -match '[:\\]') { $origFull = $r.OriginalName } else {
            # search for file in CSV's parent folder and subfolders (fallback)
            $found = Get-ChildItem -Path $csvFolder -Recurse -File -Filter $r.OriginalName -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) { $origFull = $found.FullName }
        }
    }

    $bill = ($r.BillNumber -as [string]) -replace '[\\/:*?"<>|]', '-'  # sanitize illegal chars
    $idx = $null
    if ($r.PSObject.Properties.Match('Index').Count -gt 0) { $idx = [int]$r.Index } else { $idx = ($map.Count + 1) }

    $padded = $idx.ToString().PadLeft(2,'0')
    $ext = ''
    if ($origFull) { $ext = [System.IO.Path]::GetExtension($origFull) }

    $finalName = [string]::Format($NameTemplate, $padded, $bill, $ext)

    $map.Add([pscustomobject]@{
        Index = $idx
        OriginalFullPath = $origFull
        OriginalName = $r.OriginalName
        BillNumber = $r.BillNumber
        FinalName = $finalName
        FinalFullPath = if ($origFull) { Join-Path (Split-Path $origFull -Parent) $finalName } else { '' }
        Extension = $ext
    })
}

# Show preview
foreach ($m in $map) {
    Write-Host ("{0,3}  {1,-40}  ->  {2}" -f $m.Index, ($m.OriginalName), ($m.FinalName))
    if (-not $m.OriginalFullPath) {
        Write-Host ("     WARNING: original file not found for row: {0}" -f $m.OriginalName) -ForegroundColor Yellow
    } elseif (-not $m.BillNumber) {
        Write-Host ("     WARNING: BillNumber missing for {0}" -f $m.OriginalName) -ForegroundColor Yellow
    }
}
Write-Host ''

if (-not $Apply) {
    Write-Host "DRY RUN: No changes. To apply, re-run with -Apply." -ForegroundColor Yellow
    exit 0
}

# APPLY: perform two-pass rename (in groups by folder to avoid cross-folder conflicts)
# Group by folder so renames happen where files live
$groups = $map | Where-Object { $_.OriginalFullPath } | Group-Object { Split-Path $_.OriginalFullPath -Parent }

foreach ($g in $groups) {
    $folder = $g.Name
    $items = $g.Group

    # 1) rename originals to temp GUID names
    foreach ($it in $items) {
        $orig = $it.OriginalFullPath
        $tmp = Join-Path $folder ("__tmp_" + [guid]::NewGuid().ToString() + $it.Extension)
        try {
            Move-Item -LiteralPath $orig -Destination $tmp -ErrorAction Stop
            $it | Add-Member -NotePropertyName TempPath -NotePropertyValue $tmp
            Write-Host ("TEMP: {0} -> {1}" -f (Split-Path $orig -Leaf), (Split-Path $tmp -Leaf))
        } catch {
            Write-Host ("FAILED temp rename: {0} -- {1}" -f $orig, $_.Exception.Message) -ForegroundColor Red
            Write-Error "Aborting to avoid partial state."
            exit 1
        }
    }

    # 2) rename temps to final names
    foreach ($it in $items) {
        $tmp = $it.TempPath
        $final = $it.FinalFullPath
        if (-not $final) {
            Write-Host ("SKIP (no final path): {0}" -f $it.OriginalName) -ForegroundColor Yellow
            continue
        }

        # If final path already exists, append suffix to avoid overwriting
        $finalToUse = $final
        $suf = 1
        while (Test-Path -LiteralPath $finalToUse) {
            $base = [System.IO.Path]::GetFileNameWithoutExtension($final)
            $ext = [System.IO.Path]::GetExtension($final)
            $finalToUse = Join-Path $folder ("{0} ({1}){2}" -f $base, $suf, $ext)
            $suf++
        }

        try {
            Move-Item -LiteralPath $tmp -Destination $finalToUse -ErrorAction Stop
            Write-Host ("FINAL: {0} -> {1}" -f (Split-Path $tmp -Leaf), (Split-Path $finalToUse -Leaf))
        } catch {
            Write-Host ("FAILED final rename: {0} -- {1}" -f $tmp, $_.Exception.Message) -ForegroundColor Red
            Write-Error "Aborting. Some files may still be temporary. Please inspect folder."
            exit 1
        }
    }
}

Write-Host "`nDone. Renames applied." -ForegroundColor Green
